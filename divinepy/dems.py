# AUTOGENERATED! DO NOT EDIT! File to edit: 01_dems.ipynb (unless otherwise specified).

__all__ = ['LOLA_TOPO', 't_prime', 'lat_prime']

# Cell
import math
from math import tau
from pathlib import Path

import numpy as np
import xarray as xr
from fastcore.test import is_close
from matplotlib import pyplot as plt

from divinepy import core


class LOLA_TOPO:
    """Data reader class for LOLA Topography data.

    It accesses preproduced data for 128 ppd for DEM, slope, and aspect,
    located on the luna4 disk.

    It uses virtual dask.Arrays so that virtually no memory is consumed until you
    resolve a chain of operations with the `.compute()` call.

    Attributes
    ----------
    dem: xarray.DataArray
        LOLA DEM 128 ppd
    slope: xarray.DataArray
        Slope in percent, derived from `dem` using `gdaldem` command line tool.
    aspect: xarray.DataArray
        Aspect in degrees, derived from `dem` using `gdaldem` command line tool.
    """

    root = Path("/luna4/maye/dems")
    fnames = {
        "dem": "ldem_128_topo_img.tif",
        "slope": "ldem_128_slope_img.tif",
        "aspect": "ldem_128_az_img.tif",
    }

    def __init__(self, lat_limit=None):
        self.lat_limit = lat_limit

        # assign name attributes data/slope/aspect:
        for key, fname in self.fnames.items():
            setattr(self, f"{key}_fpath", self.root / fname)
            setattr(
                self, key, core.raster_to_xarray(self.root / fname).squeeze(drop=True)
            )

        lats = np.linspace(90, -90, len(self.dem.y))
        # Note that the PDS files originally are in lon180 but Pierre's files
        # for divdata are in lon360, hence the comment out.
        # TODO: Provide different sets of DEMs to user.
        #         lons = np.linspace(-180, 180, len(self.dem.x))
        lons = np.linspace(0, 360, len(self.dem.x))

        for key in self.fnames.keys():
            o = getattr(self, key)
            o = o.assign_coords(lat=("y", lats))
            o = o.assign_coords(lon=("x", lons))
            o = o.swap_dims({"y": "lat", "x": "lon"})
            setattr(self, key, o)

    def slice_lat(self, data, lat):
        """Return the map `data` constrained to lat <= `lat`.

        Parameters
        ----------
        data: {'dem', 'slope','aspect'}
            String that choses which data product should be constrained.
        lat: int, float
            Limiting latitude value.
        """
        s = slice(lat, -lat)
        return getattr(self, data).sel(lat=s, drop=True)

    def convert_to_180longitude(self):
        "Switch all three maps to -180/180 longitude system."
        for data in ["dem", "slope", "aspect"]:
            p = getattr(self, data)
            p.coords["lon"] = (p.coords["lon"] + 180) % 360 - 180
            setattr(self, data, p.sortby(p.lon))

    def convert_to_360longitude(self):
        "Switch all three maps to 360 longitude system."
        for data in ["dem", "slope", "aspect"]:
            p = getattr(self, data)
            p.coords["lon"] = p.coords["lon"] % 360
            setattr(self, data, p.sortby(p.lon))

    def get_slope_by_pixel(self, ilat, ilon):
        """Apply scale and return dimensonless rise/run slope."""
        scale = self.slope.attrs["scales"][0]
        val = self.slope.isel(lat=ilat, lon=ilon)
        return math.tan(math.radians(val * scale))

    def get_az_by_pixel(self, ilat, ilon):
        scale = self.aspect.attrs["scales"][0]
        val = self.aspect.isel(lat=ilat, lon=ilon)
        return float(val * scale)

    def plot_dem(
        self, lat_min, lon_min, delta_lat=1, delta_lon=1, lon_max=None, lat_max=None
    ):
        plt.figure()
        if lon_max is None:
            lon_max = lon_min + delta_lon
        if lat_max is None:
            lat_max = lat_min + delta_lat
        self.dem.sel(lat=slice(lat_max, lat_min), lon=slice(lon_min, lon_max)).plot(
            cmap="viridis"
        )

# Cell
def t_prime(t, slope, az):
    """Calculate effective local time from surface slope and azimuth.

    Parameters
    ----------
    t: float
        Local time of Diviner measurement
    slope: float
        Dimensionless surface slope rise/run, i.e. slope[%] * 100
    az: float
        Azimuth angle of surface, measured from north.

    Returns
    -------
    float: Effective local time
    """
    term2 = 24 / tau * np.arctan(slope * np.sin(np.radians(az)))
    return t + term2


def lat_prime(lat, slope, az):
    """Calculate effective latitude from surface slope and azimuth.

    Parameters
    ----------
    lat: float
        Latitude of Diviner measurement
    slope: float
        Dimensionless surface slope rise/run, i.e. slope[%] * 100
    az: float
        Azimuth angle of surface, measured from north.

    Returns
    -------
    float: Effective latitude
    """
    term2 = 360 / tau * np.arctan(slope * np.cos(np.radians(az)))
    return lat + term2